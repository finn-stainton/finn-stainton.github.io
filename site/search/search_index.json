{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome Hi There! I'm Finn Stainton and you have some how landed in my Working Notes, Ramblings, Ideas and Half Complete Project write ups. This website is inspired by \u201cworking with their garage door up,\u201d mentality of being open with my current problems I'm pondering.These notes are broken up into four categories Knowledge, which are my attempt to remember learnings from university, books and hands on work of a specific area. Projects, which are write ups of personal projects Thoughts, which are working notes on long-term ideas and general happenings Misc, which as the name implies, don't fit else where. They are mainly tear downs and reviews. About Let me introduce myself, I'm a recently graduated software(Bachelor of Computer & Information Sciences)/ hobbyist hardware adventurer. Interested in creating life-enhancing software and being a great team member. Hobbies include electronics and hitting the trail. Skills If you want to know about my skills, see my Knowledge and Projects sections or please visit my Linkedin . Contact You can contact me via Email","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#welcome","text":"Hi There! I'm Finn Stainton and you have some how landed in my Working Notes, Ramblings, Ideas and Half Complete Project write ups. This website is inspired by \u201cworking with their garage door up,\u201d mentality of being open with my current problems I'm pondering.These notes are broken up into four categories Knowledge, which are my attempt to remember learnings from university, books and hands on work of a specific area. Projects, which are write ups of personal projects Thoughts, which are working notes on long-term ideas and general happenings Misc, which as the name implies, don't fit else where. They are mainly tear downs and reviews.","title":"Welcome"},{"location":"#about","text":"Let me introduce myself, I'm a recently graduated software(Bachelor of Computer & Information Sciences)/ hobbyist hardware adventurer. Interested in creating life-enhancing software and being a great team member. Hobbies include electronics and hitting the trail.","title":"About"},{"location":"#skills","text":"If you want to know about my skills, see my Knowledge and Projects sections or please visit my Linkedin .","title":"Skills"},{"location":"#contact","text":"You can contact me via Email","title":"Contact"},{"location":"knowledge/knowledge/","text":"Knowledge Welcome to my knowledge base. As you may see, it's a wee bit sparse around here. This will change over the coming months. See you around \ud83d\ude0a.","title":"Knowledge"},{"location":"knowledge/knowledge/#knowledge","text":"Welcome to my knowledge base. As you may see, it's a wee bit sparse around here. This will change over the coming months. See you around \ud83d\ude0a.","title":"Knowledge"},{"location":"knowledge/Hardware/","text":"Hardware","title":"Hardware"},{"location":"knowledge/Hardware/#hardware","text":"","title":"Hardware"},{"location":"knowledge/Hardware/Circuit%20Theory/","text":"Circuit Theory Understand the fundamental concepts of circuit theorems applicable to DC and AC circuits. Formulate theory of operational amplifier (Op amp) characteristics, Laplace equivalent of a linear circuit, frequency domain representation for electric circuits using first principles. Participate in problem solving using the circuit theorems, Op amps, Laplace, and Frequency domain analysis for various circuit designs. Design and analyse circuit models (in laboratory groups) to achieve a given specification or to validate a given hypothesis using laboratory test set rigs. Apply computer CAD tool (such as Microcap) to model circuits (linear and nonlinear) with varying levels of fidelity. Analyse trade-offs between performance, sustainability, reliability, and costs of electric circuits. Circuit theorems for DC and AC circuits, Kirchhoff\u2019s Laws, Thevenin and Norton equivalents, Nodel and Mesh analysis, Source transformation, Maximum Power transfer CAD tools for circuit analysis. Operational amplifiers; ideal and non-ideal Laplace transforms to derive dynamic response of RLC circuits and transfer functions. Active and passive filter design and analysis An introduction to two-port networks Books Electric Circuits (Tenth Edition, Global Edition) James W. Nilsson & Susan A. Riedel, Pearson, 2015","title":"Circuit Theory"},{"location":"knowledge/Hardware/Circuit%20Theory/#circuit-theory","text":"Understand the fundamental concepts of circuit theorems applicable to DC and AC circuits. Formulate theory of operational amplifier (Op amp) characteristics, Laplace equivalent of a linear circuit, frequency domain representation for electric circuits using first principles. Participate in problem solving using the circuit theorems, Op amps, Laplace, and Frequency domain analysis for various circuit designs. Design and analyse circuit models (in laboratory groups) to achieve a given specification or to validate a given hypothesis using laboratory test set rigs. Apply computer CAD tool (such as Microcap) to model circuits (linear and nonlinear) with varying levels of fidelity. Analyse trade-offs between performance, sustainability, reliability, and costs of electric circuits. Circuit theorems for DC and AC circuits, Kirchhoff\u2019s Laws, Thevenin and Norton equivalents, Nodel and Mesh analysis, Source transformation, Maximum Power transfer CAD tools for circuit analysis. Operational amplifiers; ideal and non-ideal Laplace transforms to derive dynamic response of RLC circuits and transfer functions. Active and passive filter design and analysis An introduction to two-port networks","title":"Circuit Theory"},{"location":"knowledge/Hardware/Circuit%20Theory/#books","text":"Electric Circuits (Tenth Edition, Global Edition) James W. Nilsson & Susan A. Riedel, Pearson, 2015","title":"Books"},{"location":"knowledge/Hardware/Electrical%20Principles/","text":"Electrical Priciples State and apply the first principles of electrostatics. (Range: Coulombs Law, Gauses\u2019 Law, Capacitance derivation, Concept of electric field -Solve DC circuit problems using fundamental circuit theorems (Range: Laws of Ohm and Kirchoff, Theorems of Thevenin and Norton. Superposition) State and apply the first principles of electromagnetic (Range: Concept of field, mmf, flux, flux density, Ampere\u2019s law, inductance, Mutual inductance, Faraday\u2019s and Lenzes Law) AC circuit problems using fundamental circuit theorems. (J notation, AC power, Transformer fundamentals) Define and explain the basic principles of Efficiency and Sustainability State and apply fundamentals of Operational amplifiers (Inverting amplifier, Non-inverting Understand circuits which use basic analog electronic components State and apply fundamentals of Operational amplifiers and basic filter circuitry State and apply the use of basic digital electronic functionalities Understand digital electronics circuits with Combinational Logic Circuits, Flip-Flops and Sequential Circuits and Counters Explain how electrical systems may be designed with consideration of sustainability and efficiency Books Young H.D. and Freedman R.A. Physics 12th ed. Addison-Wesley, USA (2010)","title":"Electrical Priciples"},{"location":"knowledge/Hardware/Electrical%20Principles/#electrical-priciples","text":"State and apply the first principles of electrostatics. (Range: Coulombs Law, Gauses\u2019 Law, Capacitance derivation, Concept of electric field -Solve DC circuit problems using fundamental circuit theorems (Range: Laws of Ohm and Kirchoff, Theorems of Thevenin and Norton. Superposition) State and apply the first principles of electromagnetic (Range: Concept of field, mmf, flux, flux density, Ampere\u2019s law, inductance, Mutual inductance, Faraday\u2019s and Lenzes Law) AC circuit problems using fundamental circuit theorems. (J notation, AC power, Transformer fundamentals) Define and explain the basic principles of Efficiency and Sustainability State and apply fundamentals of Operational amplifiers (Inverting amplifier, Non-inverting Understand circuits which use basic analog electronic components State and apply fundamentals of Operational amplifiers and basic filter circuitry State and apply the use of basic digital electronic functionalities Understand digital electronics circuits with Combinational Logic Circuits, Flip-Flops and Sequential Circuits and Counters Explain how electrical systems may be designed with consideration of sustainability and efficiency","title":"Electrical Priciples"},{"location":"knowledge/Hardware/Electrical%20Principles/#books","text":"Young H.D. and Freedman R.A. Physics 12th ed. Addison-Wesley, USA (2010)","title":"Books"},{"location":"knowledge/Hardware/Electronics/","text":"Fundamentals of analogue electronics, which includes semiconductor physics, PN junctions, diodes, bipolar junction transistors, junction field effect transistors, Metal Oxide Semiconductor Field Effect Transistors, and their application in linear and nonlinear circuits. Analyse electronic circuits using Nodal analysis and Thevenin\u2019s Theorem the ideal characteristics of an operational amplifier Design simple operational amplifier circuits. Analyse frequency response of circuits Design a voltage regulated power supply Contents Nodal analysis and Thevenin\u2019s Theorem Semiconductor fundamentals Circuit components: diodes, transistors Transistor amplifiers Transfer function, frequency response Linear operational amplifier Nonlinear operational amplifier Linear and switch mode power supply design A.P.Malvino and D.J.Bates, \"Electronic Principles\". McGraw-Hill.","title":"Index"},{"location":"knowledge/Hardware/Embedded%20Systems/","text":"Embedded Systems This paper covers digital signal processing and object-oriented programming in embedded systems. It includes fundamental concepts of digital signal processing, hardware and software design of microcontroller based embedded digital systems, object-oriented programming to develop embedded digital systems with a graphical user interface. Determine the input/output signals of an embedded digital systems. Analyse the hardware and software of a microcontroller-based embedded system. the stability and energy consumption issue of an embedded system. Describe the principles of object-oriented programming. Design a graphical user interface for an embedded digital system Develop an embedded digital system based on a given engineering program specification. Fundamental knowledge of signals and systems. Elementary time-domain signals and basic operations on digital time-domain signals. System as interconnections of signals. Block diagram representation of a system. System stability analysis. Hardware and software design of an embedded system. Power consumption optimization. Sustainable low power computing. Principles of object-oriented programming Development of an embedded digital system with graphical user interface using an object-oriented program Books The Firmware Handbook (1st edition) Jack Ganssle (2004). Microsoft Visual C# Step by Step (8th edition), John Sharp (2015).","title":"Embedded Systems"},{"location":"knowledge/Hardware/Embedded%20Systems/#embedded-systems","text":"This paper covers digital signal processing and object-oriented programming in embedded systems. It includes fundamental concepts of digital signal processing, hardware and software design of microcontroller based embedded digital systems, object-oriented programming to develop embedded digital systems with a graphical user interface. Determine the input/output signals of an embedded digital systems. Analyse the hardware and software of a microcontroller-based embedded system. the stability and energy consumption issue of an embedded system. Describe the principles of object-oriented programming. Design a graphical user interface for an embedded digital system Develop an embedded digital system based on a given engineering program specification. Fundamental knowledge of signals and systems. Elementary time-domain signals and basic operations on digital time-domain signals. System as interconnections of signals. Block diagram representation of a system. System stability analysis. Hardware and software design of an embedded system. Power consumption optimization. Sustainable low power computing. Principles of object-oriented programming Development of an embedded digital system with graphical user interface using an object-oriented program","title":"Embedded Systems"},{"location":"knowledge/Hardware/Embedded%20Systems/#books","text":"The Firmware Handbook (1st edition) Jack Ganssle (2004). Microsoft Visual C# Step by Step (8th edition), John Sharp (2015).","title":"Books"},{"location":"knowledge/Hardware/Microcontrollers/","text":"Microcontrollers Apply high-level (C) programming language in the development of microcontroller softwareat the register level. Design applications using the on-board input/output systems to communicate with and control external devices. Interface microcontrollers with common analogue and digital I/O devices. Use a microcontroller development platform with an in-circuit emulator Use structured and state machine software design techniques. Develop skills in the use of micro-electronic devices and systems and work cooperatively through practical work. Introduction and review of microcontroller and microprocessor systems. Features of Atmel AT Mega 128L microcontroller. Microcontroller development platform Program design, state machine design, C programming and software development. Parallel input/output devices and interfacing, analogue to digital conversion. Serial communication UART SPI and TWI. Interrupts, Timer/counters, Pulse width modulation. Control applications using, analogue and digital input/output systems. Microcontroller-based practical exercises.","title":"Microcontrollers"},{"location":"knowledge/Hardware/Microcontrollers/#microcontrollers","text":"Apply high-level (C) programming language in the development of microcontroller softwareat the register level. Design applications using the on-board input/output systems to communicate with and control external devices. Interface microcontrollers with common analogue and digital I/O devices. Use a microcontroller development platform with an in-circuit emulator Use structured and state machine software design techniques. Develop skills in the use of micro-electronic devices and systems and work cooperatively through practical work. Introduction and review of microcontroller and microprocessor systems. Features of Atmel AT Mega 128L microcontroller. Microcontroller development platform Program design, state machine design, C programming and software development. Parallel input/output devices and interfacing, analogue to digital conversion. Serial communication UART SPI and TWI. Interrupts, Timer/counters, Pulse width modulation. Control applications using, analogue and digital input/output systems. Microcontroller-based practical exercises.","title":"Microcontrollers"},{"location":"knowledge/Hardware/Signals%20and%20Systems/","text":"Signals and Systems","title":"Signals and Systems"},{"location":"knowledge/Hardware/Signals%20and%20Systems/#signals-and-systems","text":"","title":"Signals and Systems"},{"location":"knowledge/Mathematics/Discrete/","text":"Discrete Mathematics","title":"Discrete Mathematics"},{"location":"knowledge/Mathematics/Discrete/#discrete-mathematics","text":"","title":"Discrete Mathematics"},{"location":"knowledge/Software/","text":"Software","title":"Software"},{"location":"knowledge/Software/#software","text":"","title":"Software"},{"location":"knowledge/Software/Algorithms%20and%20Data%20Structures/","text":"Algorithms and Data Structures","title":"Algorithms and Data Structures"},{"location":"knowledge/Software/Algorithms%20and%20Data%20Structures/#algorithms-and-data-structures","text":"","title":"Algorithms and Data Structures"},{"location":"knowledge/Software/Android%20Mobile%20Systems/","text":"","title":"Index"},{"location":"knowledge/Software/Apple%20Software%20Creation/","text":"","title":"Index"},{"location":"knowledge/Software/Artificial%20Intelligence/","text":"[[Computer Science]]","title":"Index"},{"location":"knowledge/Software/Data%20Modeling/","text":"","title":"Index"},{"location":"knowledge/Software/Distributed%20Systems/","text":"Distributed Systems","title":"Distributed Systems"},{"location":"knowledge/Software/Distributed%20Systems/#distributed-systems","text":"","title":"Distributed Systems"},{"location":"knowledge/Software/Distributed%20Systems/Distributed%20Systems%20Principles/","text":"A #Distributed_System is a [[Computer System]] consisting of multiple processors connected together by a network which the processors use tocommunicate and coordinate their actions by passing messages The only form of communication in a sidtibutred system is presumed to be by passing messages. Messages can be affected by delays, failures and security attacks, so programming distributed systems requires more sophisticated tools the for traditional seqential software Readings [[Book: Distributed systems - Concepts and Design]] pp1-89","title":"Distributed Systems Principles"},{"location":"knowledge/Software/Distributed%20Systems/Distributed%20Systems%20Principles/#readings","text":"[[Book: Distributed systems - Concepts and Design]] pp1-89","title":"Readings"},{"location":"knowledge/Software/Distributed%20Systems/Global%20State%20Predicates/","text":"Part of: [[/Distributed Algorithms]] Abstract: ldjlfkjasdpfja","title":"Global State Predicates"},{"location":"knowledge/Software/Distributed%20Systems/Global%20State%20Predicates/#part-of-distributed-algorithms","text":"","title":"Part of: [[/Distributed Algorithms]]"},{"location":"knowledge/Software/Distributed%20Systems/Global%20State%20Predicates/#abstract-ldjlfkjasdpfja","text":"","title":"Abstract: ldjlfkjasdpfja"},{"location":"knowledge/Software/Distributed%20Systems/Remote%20Method%20Invocations/","text":"","title":"Remote Method Invocations"},{"location":"knowledge/Software/Distributed%20Systems/Snapshots/","text":"Part of [[/Distributed Algorithms]] - All clocks suffer from [[clockdrift]] - Trying to synchroize clocks involves the transmission of of a message, which itself introduces inaccuracies sinse the tansit time is usally quite variable.","title":"Snapshots"},{"location":"knowledge/Software/Linux%20Software%20Creation/","text":"","title":"Index"},{"location":"knowledge/Software/Programming%20Language%20Theory/","text":"Programming Language Theory","title":"Programming Language Theory"},{"location":"knowledge/Software/Programming%20Language%20Theory/#programming-language-theory","text":"","title":"Programming Language Theory"},{"location":"knowledge/Software/Programming%20Language%20Theory/Abstract%20Class/","text":"","title":"Abstract Class"},{"location":"knowledge/Software/Programming%20Language%20Theory/Interface/","text":"An Interface is a","title":"Interface"},{"location":"knowledge/Software/Programming%20Languages/","text":"Programming Languages","title":"Programming Languages"},{"location":"knowledge/Software/Programming%20Languages/#programming-languages","text":"","title":"Programming Languages"},{"location":"knowledge/Software/Programming%20Languages/LISP/","text":"LISP Numbers + - * / ABS SQRT Symbols Predicates NUMBERP SYMBOLP ZEROP ODDP EVENP EQUAL EQ EQL EQUALP HALF ONEMOREP NOT NOT-EQUAL AND OR XOR DEFUN Lists Con Cells LENGTH CAR CDR CAR/ CDR Derivertives CONS LIST LISTP CONSP ATOM SETF COND macro Input: many test-and-consequent clauses. (COND (test-1 consequent-1) (test-2 consequent-2) (test-3 consequent-3) .... (test-n consequent-n)) Going thought the clauses, testing. If the test passes (true) evaluates the consequent and returns its value then exits If the test failes (false), skips the consequent and tests the next clause If all tests fail. returns nil (defun compare (x y) (cond ((equal x y) \u2019numbers-are-the-same) ((< x y) \u2019first-is-smaller) ((> x y) \u2019first-is-bigger))) NTHCDR Returns the $n^{th}$ successibe cdr of a list. 0 -> the lists to many -> end of the con cell i.e. NIL (nthcdr 0 '(a b c)) => (a b c) (nthcdr 1 '(a b c)) => (b c) (nthcdr 2 '(a b c)) => (c) (nthcdr 3 '(a b c)) => NIL NTH Takes the car of the nthcdr of a list (nth 0 '(a b c) => a (nth 1 '(a b c) => b (nth 2 '(a b c) => c (nth 3 '(a b c) => nil LAST Returns the last con cell of a list (last '(all is forgiven)) => (forgiven) (last '(a b c . d)) => (c . d) (last '(rosebud) => (last '((a b c))) => REMOVE removes an item from a list (normally all occurrences). Returns a new list without the members (remove 'a '(b a n a n a)) => (b n n) is Nondestructive , Doesn't change any variable. Builts new chain of con cells Sets unordered (order doesn't matter) items appear only once MEMEBER Predicate, checks whether an item is a member of a list. Returns a sublist starting from the occurrence of the member being checked. Otherwise NIL. NEVER returns T (member 'a '(b a n d)) => (a n d) UNION takes to sets returns a list of items which appear in ether set > (union '(finger hand arm) '(toe finger foot leg)) (FINGER HAND ARM TOE FOOT LEG) union with nil returns only the non-nil set (no NIL element) a set union with itself returns itself (no duplicate elements) (defun add-vowels(L) (union '(a e i o u) L))) INTERSECTION takes two sets returns a list of items appearing in both sets or NIL if no items appear in both (intersection \u2019(fred john mary) \u2019(sue mary fred)) => (FRED MARY) intersection with nil is nil set intersection with itself is all the elements of itself (defun contains-article-p(L) (intersection '(and a the) L2)) SET-DIFFERENCE takes two sets returns the remaining elements of the first set after elements which appear in the second set have been removed not symmetric function (swapping set can have different outcomes) > (set-difference '(alpha bravo charlie delta) '(bravo charlie))) (ALPHA DELTA) SUBSETP returns T if one set is contained in another (subsetp '(a i) '(a e i o u)) \u21d2 t (subsetp '(a x) '(a e i o u)) \u21d2 nil Tables Also known as an association list (a-list) Is a List of Lists Each list is called an entry Car is the key (setf words \u2019((one un) (two deux) (three trois) (four quatre) (five cinq))) ASSOC look up's an entry in a table given it's key returns the entry (list) (have to use 'second' to get the value ) (assoc 'three words) => (three trois) RASSOC Reverse Assoc look up's an element given the cdr of it ( value ) table must be a list of dotted pairs (cow . moo) (rassoc '(moo) table) Returns as soon as it finds a match Tree SUBST FUNCALL call a function on some input (funcall #'cons 'a 'b) \u21d2 (a . b) ' (sharp quote) correct way to quote a function (ordinary only) MAPCAR applicative operator applies a function to each element of a list one at a time returns a list of the results > (defun square (n) (* n n)) > (mapcar #\u2019square \u2019(1 2 3 4 5)) (1 4 9 16 25) > (mapcar #\u2019first words) (ONE TWO THREE FOUR FIVE) LAMBDA used to pass a function definition directly into an applicative operator list called a lambda expression are functions (lambda (n) (* n n)) use sharp quote to pass an operator (mapcar #\u2019(lambda (n) (* n n)) \u2019(1 2 3 4 5)) => (1 4 9 16 25) saves writing a defun doesn't need a function name (unnamed functions) not a macro or special function doesn't need to be evaluated marker (\"this list represents a function\") synthesizing one-input functions from related functions of two inputs > (mapcar #\u2019(lambda (n) (* n 10)) \u2019(1 2 3 4 5)) => (10 20 30 40 50) FIND-IF Applicative Opperator Give a predicate and a list Finds the first element of the list for which the predicate returns true (non-NIL) returns the element or nil > (find-if #\u2019oddp \u2019(2 4 6 7 8 9)) => 7 > (defun my-assoc (key table) (find-if #\u2019(lambda (entry) (equal key (first entry))) table)) > (my-assoc \u2019two words) (TWO DEUX) REMOVE-IF applicative operator Input: Predicate, List Removes all the items from a list that satisfy the predicate Returns a list of remaining items (non-satisfing) (remove-if #\u2019numberp \u2019(2 for 1 sale)) => (FOR SALE) PLUSP test a number if it is greater than zero REMOVE-IF-NOT applicative operator Input: Predicate, List Inverts the predicate, So removes all the items from a list which return nil from the original predicate Returns a list of items which satisfy the predicate > (remove-if-not #\u2019plusp \u2019(2 0 -4 6 -8 10)) (2 6 10) > (remove-if-not #\u2019oddp \u2019(2 0 -4 6 -8 10)) NIL REDUCE applicative operator reduces elements of a list into a single result Input: Function (sharp quote), List Function must accept two inputs (reduce #'+ '(1 2 3)) => 6 (reduce #'* '(2 4 5)) => 40 can be applied to lists of lists > (reduce #\u2019append\u2019((one un) (two deux) (three trois))) (ONE UN TWO DEUX THREE TROIS) EVERY Input: Predicate (#'), List Returns T if there is no element that causes the predicate to return false (every #'numberp '(1 2 3 4 5)) => T (every #'numberp '(1 2 A B C 5)) => NIL WHEN, UNLESS conditional form evaluate more that one expression if when test results nil, returns nil non-nil, evaluates its body returning the last one (WHEN test body) if unless test results non-nil, returns nil (UNLESS test body) DO Macro bind any number of variables step any number of index variables specify own test (DO ((var1 init1 [update1]) (var2 init2 [update2]) ...) (test action-1 ... action-n) body) each variable is initialed a value test form is evaluated True => DO evaluates the termination actions and returns the value of the last one. False => DO evaluates the forms in its body in order Body may contain returns Completes another loop when DO reachs the end of the body each variable updates to the value of the update expression (may be omitted, value is unchanged) Termination test Evaluates body (defun launch (n) (do ((cnt n (- cnt 1))) ((zerop cnt) (format t \"Blast off!\")) (format t \"~S...\" cnt))) > (launch 10) 10...9...8...7...6...5...4...3...2...1...Blast off! NIL DOTIMES iterative form macros (don't evaluate all arguments) (DOTIMES (index-var n [result-form]) body) evaluates body n times ( zero through n-1 ) Returns values of result-form (nil if omitted) > (dotimes (i 4) (format t \"~&I is ~S.\" i)) I is 0. I is 1. I is 2. I is 3. NIL DOLIST (DOLIST (index-var list [result-form]) body) - steps index variable through the elements of a list > (dolist (x \u2019(red blue green) \u2019flowers) (format t \"~&Roses are ~S.\" x)) Roses are RED. Roses are BLUE. Roses are GREEN. FLOWERS RETURN Input: value to return LET &OPTIONAL if unsupplied, defaults to NIL (can be changed via (name default) ) (defun foo (x &optional y) (format t \"~&X is ~S\" x) (format t \"~&Y is ~S\" y) (list x y)) > (foo 3 5) X is 3 Y is 5 (3 5) > (foo 4) X is 4 Y is NIL (4 NIL) &REST (defun average (&rest args) (/ (reduce #\u2019+ args) (length args) 1.0)) > (average 1 2 3 4 5) \u21d2 3.0 KEYWORD ARGUMENTS TYPEP (typep 3 'numberp) => t TYPE-OF FORMAT Inputs 1. T, to write to the screen 2. String, ( format control string ) - writes to screen without \"\" - special formatting starting with ~ - ~% => new line - ~%~% => blank line - ~& => new line unless already at the start of a new line - ~S => inserts a printed rep of an objects which follows the \"\" > (format t \"From ~S to ~S in ~S minutes!\" \u2019boston \u2019(new york) 55) From BOSTON to (NEW YORK) in 55 minutes! NIL - ~A => prints object without escape characters e.g. quotation mark","title":"LISP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#lisp","text":"","title":"LISP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#numbers","text":"","title":"Numbers"},{"location":"knowledge/Software/Programming%20Languages/LISP/#_1","text":"","title":"+"},{"location":"knowledge/Software/Programming%20Languages/LISP/#-","text":"","title":"-"},{"location":"knowledge/Software/Programming%20Languages/LISP/#_2","text":"","title":"*"},{"location":"knowledge/Software/Programming%20Languages/LISP/#_3","text":"","title":"/"},{"location":"knowledge/Software/Programming%20Languages/LISP/#abs","text":"","title":"ABS"},{"location":"knowledge/Software/Programming%20Languages/LISP/#sqrt","text":"","title":"SQRT"},{"location":"knowledge/Software/Programming%20Languages/LISP/#symbols","text":"","title":"Symbols"},{"location":"knowledge/Software/Programming%20Languages/LISP/#predicates","text":"","title":"Predicates"},{"location":"knowledge/Software/Programming%20Languages/LISP/#numberp","text":"","title":"NUMBERP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#symbolp","text":"","title":"SYMBOLP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#zerop","text":"","title":"ZEROP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#oddp","text":"","title":"ODDP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#evenp","text":"","title":"EVENP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#equal","text":"","title":"EQUAL"},{"location":"knowledge/Software/Programming%20Languages/LISP/#eq","text":"","title":"EQ"},{"location":"knowledge/Software/Programming%20Languages/LISP/#eql","text":"","title":"EQL"},{"location":"knowledge/Software/Programming%20Languages/LISP/#equalp","text":"","title":"EQUALP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#half","text":"","title":"HALF"},{"location":"knowledge/Software/Programming%20Languages/LISP/#onemorep","text":"","title":"ONEMOREP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#not","text":"","title":"NOT"},{"location":"knowledge/Software/Programming%20Languages/LISP/#not-equal","text":"","title":"NOT-EQUAL"},{"location":"knowledge/Software/Programming%20Languages/LISP/#and","text":"","title":"AND"},{"location":"knowledge/Software/Programming%20Languages/LISP/#or","text":"","title":"OR"},{"location":"knowledge/Software/Programming%20Languages/LISP/#xor","text":"","title":"XOR"},{"location":"knowledge/Software/Programming%20Languages/LISP/#defun","text":"","title":"DEFUN"},{"location":"knowledge/Software/Programming%20Languages/LISP/#lists","text":"","title":"Lists"},{"location":"knowledge/Software/Programming%20Languages/LISP/#con-cells","text":"","title":"Con Cells"},{"location":"knowledge/Software/Programming%20Languages/LISP/#length","text":"","title":"LENGTH"},{"location":"knowledge/Software/Programming%20Languages/LISP/#car","text":"","title":"CAR"},{"location":"knowledge/Software/Programming%20Languages/LISP/#cdr","text":"","title":"CDR"},{"location":"knowledge/Software/Programming%20Languages/LISP/#car-cdr-derivertives","text":"","title":"CAR/ CDR Derivertives"},{"location":"knowledge/Software/Programming%20Languages/LISP/#cons","text":"","title":"CONS"},{"location":"knowledge/Software/Programming%20Languages/LISP/#list","text":"","title":"LIST"},{"location":"knowledge/Software/Programming%20Languages/LISP/#listp","text":"","title":"LISTP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#consp","text":"","title":"CONSP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#atom","text":"","title":"ATOM"},{"location":"knowledge/Software/Programming%20Languages/LISP/#setf","text":"","title":"SETF"},{"location":"knowledge/Software/Programming%20Languages/LISP/#cond","text":"macro Input: many test-and-consequent clauses. (COND (test-1 consequent-1) (test-2 consequent-2) (test-3 consequent-3) .... (test-n consequent-n)) Going thought the clauses, testing. If the test passes (true) evaluates the consequent and returns its value then exits If the test failes (false), skips the consequent and tests the next clause If all tests fail. returns nil (defun compare (x y) (cond ((equal x y) \u2019numbers-are-the-same) ((< x y) \u2019first-is-smaller) ((> x y) \u2019first-is-bigger)))","title":"COND"},{"location":"knowledge/Software/Programming%20Languages/LISP/#nthcdr","text":"Returns the $n^{th}$ successibe cdr of a list. 0 -> the lists to many -> end of the con cell i.e. NIL (nthcdr 0 '(a b c)) => (a b c) (nthcdr 1 '(a b c)) => (b c) (nthcdr 2 '(a b c)) => (c) (nthcdr 3 '(a b c)) => NIL","title":"NTHCDR"},{"location":"knowledge/Software/Programming%20Languages/LISP/#nth","text":"Takes the car of the nthcdr of a list (nth 0 '(a b c) => a (nth 1 '(a b c) => b (nth 2 '(a b c) => c (nth 3 '(a b c) => nil","title":"NTH"},{"location":"knowledge/Software/Programming%20Languages/LISP/#last","text":"Returns the last con cell of a list (last '(all is forgiven)) => (forgiven) (last '(a b c . d)) => (c . d) (last '(rosebud) => (last '((a b c))) =>","title":"LAST"},{"location":"knowledge/Software/Programming%20Languages/LISP/#remove","text":"removes an item from a list (normally all occurrences). Returns a new list without the members (remove 'a '(b a n a n a)) => (b n n) is Nondestructive , Doesn't change any variable. Builts new chain of con cells","title":"REMOVE"},{"location":"knowledge/Software/Programming%20Languages/LISP/#sets","text":"unordered (order doesn't matter) items appear only once","title":"Sets"},{"location":"knowledge/Software/Programming%20Languages/LISP/#memeber","text":"Predicate, checks whether an item is a member of a list. Returns a sublist starting from the occurrence of the member being checked. Otherwise NIL. NEVER returns T (member 'a '(b a n d)) => (a n d)","title":"MEMEBER"},{"location":"knowledge/Software/Programming%20Languages/LISP/#union","text":"takes to sets returns a list of items which appear in ether set > (union '(finger hand arm) '(toe finger foot leg)) (FINGER HAND ARM TOE FOOT LEG) union with nil returns only the non-nil set (no NIL element) a set union with itself returns itself (no duplicate elements) (defun add-vowels(L) (union '(a e i o u) L)))","title":"UNION"},{"location":"knowledge/Software/Programming%20Languages/LISP/#intersection","text":"takes two sets returns a list of items appearing in both sets or NIL if no items appear in both (intersection \u2019(fred john mary) \u2019(sue mary fred)) => (FRED MARY) intersection with nil is nil set intersection with itself is all the elements of itself (defun contains-article-p(L) (intersection '(and a the) L2))","title":"INTERSECTION"},{"location":"knowledge/Software/Programming%20Languages/LISP/#set-difference","text":"takes two sets returns the remaining elements of the first set after elements which appear in the second set have been removed not symmetric function (swapping set can have different outcomes) > (set-difference '(alpha bravo charlie delta) '(bravo charlie))) (ALPHA DELTA)","title":"SET-DIFFERENCE"},{"location":"knowledge/Software/Programming%20Languages/LISP/#subsetp","text":"returns T if one set is contained in another (subsetp '(a i) '(a e i o u)) \u21d2 t (subsetp '(a x) '(a e i o u)) \u21d2 nil","title":"SUBSETP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#tables","text":"Also known as an association list (a-list) Is a List of Lists Each list is called an entry Car is the key (setf words \u2019((one un) (two deux) (three trois) (four quatre) (five cinq)))","title":"Tables"},{"location":"knowledge/Software/Programming%20Languages/LISP/#assoc","text":"look up's an entry in a table given it's key returns the entry (list) (have to use 'second' to get the value ) (assoc 'three words) => (three trois)","title":"ASSOC"},{"location":"knowledge/Software/Programming%20Languages/LISP/#rassoc","text":"Reverse Assoc look up's an element given the cdr of it ( value ) table must be a list of dotted pairs (cow . moo) (rassoc '(moo) table) Returns as soon as it finds a match","title":"RASSOC"},{"location":"knowledge/Software/Programming%20Languages/LISP/#tree","text":"","title":"Tree"},{"location":"knowledge/Software/Programming%20Languages/LISP/#subst","text":"","title":"SUBST"},{"location":"knowledge/Software/Programming%20Languages/LISP/#funcall","text":"call a function on some input (funcall #'cons 'a 'b) \u21d2 (a . b)","title":"FUNCALL"},{"location":"knowledge/Software/Programming%20Languages/LISP/#sharp-quote-correct-way-to-quote-a-function-ordinary-only","text":"","title":"' (sharp quote) correct way to quote a function (ordinary only)"},{"location":"knowledge/Software/Programming%20Languages/LISP/#mapcar","text":"applicative operator applies a function to each element of a list one at a time returns a list of the results > (defun square (n) (* n n)) > (mapcar #\u2019square \u2019(1 2 3 4 5)) (1 4 9 16 25) > (mapcar #\u2019first words) (ONE TWO THREE FOUR FIVE)","title":"MAPCAR"},{"location":"knowledge/Software/Programming%20Languages/LISP/#lambda","text":"used to pass a function definition directly into an applicative operator list called a lambda expression are functions (lambda (n) (* n n)) use sharp quote to pass an operator (mapcar #\u2019(lambda (n) (* n n)) \u2019(1 2 3 4 5)) => (1 4 9 16 25) saves writing a defun doesn't need a function name (unnamed functions) not a macro or special function doesn't need to be evaluated marker (\"this list represents a function\") synthesizing one-input functions from related functions of two inputs > (mapcar #\u2019(lambda (n) (* n 10)) \u2019(1 2 3 4 5)) => (10 20 30 40 50)","title":"LAMBDA"},{"location":"knowledge/Software/Programming%20Languages/LISP/#find-if","text":"Applicative Opperator Give a predicate and a list Finds the first element of the list for which the predicate returns true (non-NIL) returns the element or nil > (find-if #\u2019oddp \u2019(2 4 6 7 8 9)) => 7 > (defun my-assoc (key table) (find-if #\u2019(lambda (entry) (equal key (first entry))) table)) > (my-assoc \u2019two words) (TWO DEUX)","title":"FIND-IF"},{"location":"knowledge/Software/Programming%20Languages/LISP/#remove-if","text":"applicative operator Input: Predicate, List Removes all the items from a list that satisfy the predicate Returns a list of remaining items (non-satisfing) (remove-if #\u2019numberp \u2019(2 for 1 sale)) => (FOR SALE)","title":"REMOVE-IF"},{"location":"knowledge/Software/Programming%20Languages/LISP/#plusp","text":"test a number if it is greater than zero","title":"PLUSP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#remove-if-not","text":"applicative operator Input: Predicate, List Inverts the predicate, So removes all the items from a list which return nil from the original predicate Returns a list of items which satisfy the predicate > (remove-if-not #\u2019plusp \u2019(2 0 -4 6 -8 10)) (2 6 10) > (remove-if-not #\u2019oddp \u2019(2 0 -4 6 -8 10)) NIL","title":"REMOVE-IF-NOT"},{"location":"knowledge/Software/Programming%20Languages/LISP/#reduce","text":"applicative operator reduces elements of a list into a single result Input: Function (sharp quote), List Function must accept two inputs (reduce #'+ '(1 2 3)) => 6 (reduce #'* '(2 4 5)) => 40 can be applied to lists of lists > (reduce #\u2019append\u2019((one un) (two deux) (three trois))) (ONE UN TWO DEUX THREE TROIS)","title":"REDUCE"},{"location":"knowledge/Software/Programming%20Languages/LISP/#every","text":"Input: Predicate (#'), List Returns T if there is no element that causes the predicate to return false (every #'numberp '(1 2 3 4 5)) => T (every #'numberp '(1 2 A B C 5)) => NIL","title":"EVERY"},{"location":"knowledge/Software/Programming%20Languages/LISP/#when-unless","text":"conditional form evaluate more that one expression if when test results nil, returns nil non-nil, evaluates its body returning the last one (WHEN test body) if unless test results non-nil, returns nil (UNLESS test body)","title":"WHEN, UNLESS"},{"location":"knowledge/Software/Programming%20Languages/LISP/#do","text":"Macro bind any number of variables step any number of index variables specify own test (DO ((var1 init1 [update1]) (var2 init2 [update2]) ...) (test action-1 ... action-n) body) each variable is initialed a value test form is evaluated True => DO evaluates the termination actions and returns the value of the last one. False => DO evaluates the forms in its body in order Body may contain returns Completes another loop when DO reachs the end of the body each variable updates to the value of the update expression (may be omitted, value is unchanged) Termination test Evaluates body (defun launch (n) (do ((cnt n (- cnt 1))) ((zerop cnt) (format t \"Blast off!\")) (format t \"~S...\" cnt))) > (launch 10) 10...9...8...7...6...5...4...3...2...1...Blast off! NIL","title":"DO"},{"location":"knowledge/Software/Programming%20Languages/LISP/#dotimes","text":"iterative form macros (don't evaluate all arguments) (DOTIMES (index-var n [result-form]) body) evaluates body n times ( zero through n-1 ) Returns values of result-form (nil if omitted) > (dotimes (i 4) (format t \"~&I is ~S.\" i)) I is 0. I is 1. I is 2. I is 3. NIL","title":"DOTIMES"},{"location":"knowledge/Software/Programming%20Languages/LISP/#dolist","text":"(DOLIST (index-var list [result-form]) body) - steps index variable through the elements of a list > (dolist (x \u2019(red blue green) \u2019flowers) (format t \"~&Roses are ~S.\" x)) Roses are RED. Roses are BLUE. Roses are GREEN. FLOWERS","title":"DOLIST"},{"location":"knowledge/Software/Programming%20Languages/LISP/#return","text":"Input: value to return","title":"RETURN"},{"location":"knowledge/Software/Programming%20Languages/LISP/#let","text":"","title":"LET"},{"location":"knowledge/Software/Programming%20Languages/LISP/#optional","text":"if unsupplied, defaults to NIL (can be changed via (name default) ) (defun foo (x &optional y) (format t \"~&X is ~S\" x) (format t \"~&Y is ~S\" y) (list x y)) > (foo 3 5) X is 3 Y is 5 (3 5) > (foo 4) X is 4 Y is NIL (4 NIL)","title":"&amp;OPTIONAL"},{"location":"knowledge/Software/Programming%20Languages/LISP/#rest","text":"(defun average (&rest args) (/ (reduce #\u2019+ args) (length args) 1.0)) > (average 1 2 3 4 5) \u21d2 3.0","title":"&amp;REST"},{"location":"knowledge/Software/Programming%20Languages/LISP/#keyword-arguments","text":"","title":"KEYWORD ARGUMENTS"},{"location":"knowledge/Software/Programming%20Languages/LISP/#typep","text":"(typep 3 'numberp) => t","title":"TYPEP"},{"location":"knowledge/Software/Programming%20Languages/LISP/#type-of","text":"","title":"TYPE-OF"},{"location":"knowledge/Software/Programming%20Languages/LISP/#format","text":"Inputs 1. T, to write to the screen 2. String, ( format control string ) - writes to screen without \"\" - special formatting starting with ~ - ~% => new line - ~%~% => blank line - ~& => new line unless already at the start of a new line - ~S => inserts a printed rep of an objects which follows the \"\" > (format t \"From ~S to ~S in ~S minutes!\" \u2019boston \u2019(new york) 55) From BOSTON to (NEW YORK) in 55 minutes! NIL - ~A => prints object without escape characters e.g. quotation mark","title":"FORMAT"},{"location":"knowledge/Software/Software%20Creation/","text":"","title":"Index"},{"location":"knowledge/Software/Theory%20of%20Computation/","text":"Theory of Computation","title":"Theory of Computation"},{"location":"knowledge/Software/Theory%20of%20Computation/#theory-of-computation","text":"","title":"Theory of Computation"},{"location":"knowledge/Software/Web%20Systems/","text":"","title":"Index"},{"location":"misc/S-AIR%20Sony%20Wireless%20Amplifier/S-AIR%20Sony%20Wireless%20Amplifier/","text":"S-AIR Came across this Sony S-AIR Amplifier while at the local waste recycling shop and thought it may be of interest to me. I had never heard of \"S-AIR\" before so was intrigued. External Taking a look at the device it is 205mm wide by 210mm deep and 55mm tall. It has a single tactic power button on the front with what is labeled as \"S-AIR/STANDBY\" LED indicator. On the rear, it is labeled as Model No. TA-SA200WR, Surround Amplifier. It has two labeled section, the first being \"S-AIR ID\" which has a three way slide switch with A, B and C positions. It also has a PAIRING button with associated LED. The second section, speakers has Left and Right two pin connectors which can support 3-16 ohm impedance speakers. There is also a two way slide switch which controls the surround position. Tear Down Internals","title":"S-AIR"},{"location":"misc/S-AIR%20Sony%20Wireless%20Amplifier/S-AIR%20Sony%20Wireless%20Amplifier/#s-air","text":"Came across this Sony S-AIR Amplifier while at the local waste recycling shop and thought it may be of interest to me. I had never heard of \"S-AIR\" before so was intrigued.","title":"S-AIR"},{"location":"misc/S-AIR%20Sony%20Wireless%20Amplifier/S-AIR%20Sony%20Wireless%20Amplifier/#external","text":"Taking a look at the device it is 205mm wide by 210mm deep and 55mm tall. It has a single tactic power button on the front with what is labeled as \"S-AIR/STANDBY\" LED indicator. On the rear, it is labeled as Model No. TA-SA200WR, Surround Amplifier. It has two labeled section, the first being \"S-AIR ID\" which has a three way slide switch with A, B and C positions. It also has a PAIRING button with associated LED. The second section, speakers has Left and Right two pin connectors which can support 3-16 ohm impedance speakers. There is also a two way slide switch which controls the surround position.","title":"External"},{"location":"misc/S-AIR%20Sony%20Wireless%20Amplifier/S-AIR%20Sony%20Wireless%20Amplifier/#tear-down","text":"","title":"Tear Down"},{"location":"misc/S-AIR%20Sony%20Wireless%20Amplifier/S-AIR%20Sony%20Wireless%20Amplifier/#internals","text":"","title":"Internals"},{"location":"projects/","text":"Projects","title":"Projects"},{"location":"projects/#projects","text":"","title":"Projects"},{"location":"projects/Spelling%20App/","text":"","title":"Spelling App"},{"location":"thoughts/20211107_New_Site/","text":"New Website Have been looking at improving my web page for a while now. I was looking at gatsby, which do look good, there portfolio and blog templates always included a little to many features which weren't easy to remove. I also enjoy the simplistic of markdown, and elegance of material ui so combined them with choosing Material for mkdocs . As you may see, it's a little sparse around here currently.","title":"New Website"},{"location":"thoughts/20211107_New_Site/#new-website","text":"Have been looking at improving my web page for a while now. I was looking at gatsby, which do look good, there portfolio and blog templates always included a little to many features which weren't easy to remove. I also enjoy the simplistic of markdown, and elegance of material ui so combined them with choosing Material for mkdocs . As you may see, it's a little sparse around here currently.","title":"New Website"}]}