# Algorithms and Complexity (AL)

## [AL/Basic Analysis](01_Basic-Analysis.md)

**Topics**:

- Differences among best, expected, and worst case behaviors of an algorithm
- Asymptotic analysis of upper and expected complexity bounds
- Big O notation: formal definition
- Complexity classes, such as constant, logarithmic, linear, quadratic, and exponential
- Empirical measurements of performance
- Time and space trade-offs in algorithms
- Big O notation: use
- Little o, big omega and big theta notation
- Recurrence relations
- Analysis of iterative and recursive algorithms
- Some version of a Master Theorem

## [AL/Algorithmic Strategies](02_Algorithmic-Strategies.md)

**Topics:**

- Brute-force algorithms
- Greedy algorithms
- Divide-and-conquer (cross-reference SDF/Algorithms and Design/Problem-solving strategies)
- Recursive backtracking
- Dynamic Programming
- Branch-and-bound
- Heuristics
- Reduction: transform-and-conquer

## [AL/Fundamental Data Structures and Algorithms](03_Fundamental-Data-Structures-Algorithms.md)

**Topics**:

- Simple numerical algorithms, such as computing the average of a list of numbers, finding the min, max, and mode in a list, approximating the square root of a number, or finding the greatest common divisor
- Sequential and binary search algorithms
- Worst case quadratic sorting algorithms (selection, insertion)
- Worst or average case O(N log N) sorting algorithms (quicksort, heapsort, mergesort)
- Hash tables, including strategies for avoiding and resolving collisions
- Binary search trees
    - Common operations on binary search trees such as select min, max, insert, delete, iterate over tree
- Graphs and graph algorithms
    - Representations of graphs (e.g., adjacency list, adjacency matrix)
    - Depth- and breadth-first traversals
- Heaps
- Graphs and graph algorithms
    - Shortest-path algorithms (Dijkstra’s and Floyd’s algorithms)
    - Minimum spanning tree (Prim’s and Kruskal’s algorithms)
- Pattern matching and string/text algorithms (e.g., substring matching, regular expression matching, longest
common subsequence algorithms)

## [AL/Advanced Data Structures, Algorithms and Analysis](04_Advanced-Data-Structures-Algorithms.md)

**Topics**:

- Balanced trees (e.g., AVL trees, red-black trees, splay trees, treaps)
- Graphs (e.g., topological sort, finding strongly connected components, matching)
- Advanced data structures (e.g., B-trees, Fibonacci heaps)
- String-based data structures and algorithms (e.g., suffix arrays, suffix trees, tries)
- Network flows (e.g., max flow [Ford-Fulkerson algorithm], max flow – min cut, maximum bipartite
matching)
- Linear Programming (e.g., duality, simplex method, interior point algorithms)
- Number-theoretic algorithms (e.g., modular arithmetic, primality testing, integer factorization)
- Geometric algorithms (e.g., points, line segments, polygons. [properties, intersections], finding convex hull, spatial decomposition, collision detection, geometric search/proximity)
- Randomized algorithms
- Stochastic algorithms
- Approximation algorithms
- Amortized analysis
- Probabilistic analysis
- Online algorithms and competitive analysis

## [AL/Basic Automata Computability and Complexity](05_Basic-Automata-Computability-Complexity.md)

**Topics**:

- Finite-state machines
- Regular expressions
- The halting problem
- Context-free grammars (cross-reference PL/Syntax Analysis)
- Introduction to the P and NP classes and the P vs. NP problem
- Introduction to the NP-complete class and exemplary NP-complete problems (e.g., SAT, Knapsack)

## [AL/Advanced Computational Complexity](06_Advanced-Computational-Complexity.md)

**Topics**:

- Review of the classes P and NP; introduce P-space and EXP
- Polynomial hierarchy
- NP-completeness (Cook’s theorem)
- Classic NP-complete problems
- Reduction Techniques

## [AL/Advanced Automata Theory and Computability](07_Advanced-Automata-Computability.md)

**Topics**:

- Sets and languages
    - Regular languages
    - Review of deterministic finite automata (DFAs)
    - Nondeterministic finite automata (NFAs)
    - Equivalence of DFAs and NFAs
    - Review of regular expressions; their equivalence to finite automata
    - Closure properties
    - Proving languages non-regular, via the pumping lemma or alternative means
- Context-free languages
    - Push-down automata (PDAs)
    - Relationship of PDAs and context-free grammars
    - Properties of context-free languages
- Turing machines, or an equivalent formal model of universal computation
- Nondeterministic Turing machines
- Chomsky hierarchy
- The Church-Turing thesis
- Computability
- Rice’s Theorem
- Examples of uncomputable functions
- Implications of uncomputability
